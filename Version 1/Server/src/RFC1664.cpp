//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : Projet Chat
//  @ File Name : RFC1664.cpp
//  @ Date : 28/10/2013
//  @ Author :
//
//


#include "RFC1664.hpp"
#include "MessagesTypesRFC1664.hpp"
#include "ErrorCodes.hpp"
#include <cstring>
#include <stdio.h>
#include <string>
#include <sstream>
#include <iostream>

/**
 * renvoi le type d'un message
 * @see MessagesTypesRFC1664
 * @param msg la string dont le type est a définir
 * @return le numero correspondant au type de message
 */
MessagesTypesRFC1664 RFC1664::type(string msg) {
    std::size_t found = msg.find("CON§", 0);
    if (found != string::npos)
        return MSG_CON;

    found = msg.find("DECO§", 0);
    if (found != string::npos)
        return MSG_DECO;

    found = msg.find("ROOM_QUIT§", 0);
    if (found != string::npos)
        return MSG_ROOM_QUIT;

    found = msg.find("ROOM_CREATE§", 0);
    if (found != string::npos)
        return MSG_ROOM_CREATE;

    found = msg.find("ROOM_JOIN§", 0);
    if (found != string::npos)
        return MSG_ROOM_JOIN;

    found = msg.find("BOOK_LIST_RQST§", 0);
    if (found != string::npos)
        return MSG_BOOK_LIST_RQST;

    found = msg.find("BOOK_LIST_RESP§", 0);
    if (found != string::npos)
        return MSG_BOOK_LIST_RESP;

    found = msg.find("COM§", 0);
    if (found != string::npos)
        return MSG_COM;

    found = msg.find("KEEP_ALIVE§", 0);
    if (found != string::npos)
        return MSG_LIVE;

    found = msg.find("ACK§", 0);
    if (found != string::npos)
        return MSG_ACK;

    return ERR_BAD_MESSAGE;

}

/**
 * Créé un message de quittage de room
 * @param clientName le nom du cliant quittant le salon
 * @param roomName le nom du salon quitté
 * @return le message formé
 */
string RFC1664::createMsgRoomQuit(string clientName, string roomName) {
    string retour = "ROOM_QUIT§" + clientName + "§" + roomName+"§";
    return retour;
}

/**
 * Créé un message permettant de rejoindre une room
 * @param clientName le nom du client rejoingnant la room
 * @param roomName le nom du salon rejoint
 * @return le message formé
 */
string RFC1664::createMsgRoomJoin(string clientName, string roomName) {
    string retour = "ROOM_JOIN§" + clientName + "§" + roomName+"§";
    return retour;
}

/**
 * Créé un message de creation de room
 * @param clientName le nom du client à l'initiative de la creation
 * @param roomName le nom du salon à creer
 * @return le message formé
 */
string RFC1664::createMsgRoomCreate(string clientName, string roomName) {
    string retour = "ROOM_CREATE§" + clientName + "§" + roomName + "§";
    return retour;
}

/**
 * Créé un message de demande d'annuaire
 * @param clientName le nom du client demandant l'annuaire
 * @return le message formé
 */
string RFC1664::createMsgBookListRqst(string clientName) {
    string retour = "BOOK_LIST_RQST§" + clientName+"§";
    return retour;
}

/**
 * Créé un message de réponse d'annuaire
 * @param clientName le nom du client
 * @param ip son adresse ip
 * @param port sont port d'ecoute
 * @param roomNb le nombre de salons dans lequel il se trouve
 * @param rooms le vector contenant la liste des salons dans lequel il se trouve
 * @return le message formé
 */
string RFC1664::createMsgBookListResp(string clientName, string ip, string port, int roomNb, vector<Room*> rooms) {
    string sRoomNb = to_string(roomNb);
    string retour = "BOOK_LIST_RESP§" + clientName + "§" + ip + "§" + port + "§" + sRoomNb+"§";

    vector<Room*>::iterator it;
    for (it = rooms.begin(); it != rooms.end(); ++it) {

        retour += (*it)->getName();
        retour += "§";
    }

    return retour;
}

string RFC1664::createMsgBookListResp(string clientName, string ip, string port, int roomNb, vector<Room*> *rooms) {
    cout << "NB de ROOMS DU CLIENT DANS LA FONCITON " << roomNb << " " << endl;
    string sRoomNb = to_string(roomNb);
    cout << "NGGGGGGGGGGGGGGGGGGGG " << roomNb << " " << endl;
    string retour = "BOOK_LIST_RESP§" + clientName + "§" + ip + "§" + port + "§" + sRoomNb+"§";
    cout << "HHHHHHHHHHHHHHHHHHHHHHHHH" << roomNb << " " << endl;

    vector<Room*>::iterator it;
    cout << "IIIIIIIIIIIIIIIIIIIIIIIIIIII" << roomNb << " " << endl;
    for (it = rooms->begin(); it != rooms->end(); ++it) {
        cout << " FOR 1 " << endl;
        retour += (*it)->getName();
        cout << " FOR 2 " << endl;
        retour += "§";
        cout << " FOR 3 " << endl;
    }

    cout << "prout 2 "<< endl;

    return retour;
}

/**
 * Crée un message de deconnection
 *
 * @param clientName le nom du client se déconnectant
 * @return le message formé
 */
string RFC1664::createMsgDeco(string clientName) {

    string retour = "DECO§" + clientName+"§";
    return retour;
}

/**
 * Créé un message de connection
 *
 * @param clientName le nom du client désirant se connecter
 * @param addressIp son adresse ip
 * @return le message formé
 */
string RFC1664::createMsgCon(string clientName, string addressIp, string port) {
    string retour = "CON§" + clientName + "§" + addressIp +"§" + port = "§";
    return retour;
}

/**
 * Créé un message contenant un message de chat a envoyer a un client
 *
 * @param senderName l'emetteur du message
 * @param receiverName le destinataire du message
 * @param message le contenu du message
 * @param roomName le salon du message
 * @return le message formé
 */
string RFC1664::createMsgCom(string senderName, string receiverName, string message, string roomName) {
    string retour = "COM§" + senderName + "§" + receiverName + "§" + message + "§" + roomName+"§";
    return retour;
}

/**
 * créé un message de signalisation pour le maintient dans l'annuaire
 * @param clientName le nom du client se signalant
 * @return le message formé
 */
string RFC1664::createMsgKeepAlive(string clientName) {
    string retour = "KEEP_ALIVE§" + clientName+"§";
    return retour;
}

/**
 * creer un message d'aquittement
 * @param message le message d'aquittement
 * @return le message formé
 */
string RFC1664::createMsgAck(string message) {
    string retour = "ACK§" + message + "§";
    return retour;
}

/*
string RFC1664::fieldFromMesg(string msg, int fieldNb, char delim) {
    string retour;
    istringstream iss(msg);
    string mot;
    //char delim = '§';
    int i = 1;
    while (std::getline(iss, mot, delim) && (i < fieldNb)) {
        //cout << i << endl;
        i++;
        //cout << i << endl;
        //cout << mot << endl;
    }
    //cout << mot<<endl;
    mot.erase(mot.size() - 1, 1);
    retour = mot;

    return retour;
}*/

/** récupère un champ d'un message en fonction d'un délimiteur
 *
 * @param msg de message à découper
 * @param fieldNb le numéro de champs a récuperer
 * @param delimiter le délimiteur du message
 * @return le champ numéro @fieldNB
 */
string RFC1664::fieldFromMesg(string msg, int fieldNb, string delimiter) {

    //string delimiter = "§";
    string retour;
    size_t pos = 0;
    std::string token;
    int i = 0;
    while ((pos = msg.find(delimiter)) != std::string::npos && (i < fieldNb)) {
        i++;
        token = msg.substr(0, pos);
        //retour=token;
        msg.erase(0, pos + delimiter.length());
    }
    retour=token;
    //cout<<retour;

    return retour;
}

